"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve 
  deployment information for ZumaEvents.sol:
  
  - <root>/packages/site/abi/ZumaEventsABI.ts
  - <root>/packages/site/abi/ZumaEventsAddresses.ts
*/
import { ZumaEventsAddresses } from "@/abi/ZumaEventsAddresses";
import { ZumaEventsABI } from "@/abi/ZumaEventsABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type EventData = {
  name: string;
  description: string;
  dateTime: string;
  location: string;
  isOpen: boolean;
  minAge: string;
  minSkill: string;
  acceptedCount: string;
};

export type EventForm = {
  name: string;
  description: string;
  dateTime: string;
  location: string;
  minAge: string;
  minSkill: string;
};

export type AttendanceForm = {
  eventId: string;
  age: string;
  skill: string;
};

export type CreatedEvent = {
  id: number;
  name: string;
  minAge: number;
  minSkill: number;
};

export type AttendanceResult = {
  eventId: number;
  age: number;
  skill: number;
  accepted: boolean;
};

type ZumaEventsInfoType = {
  abi: typeof ZumaEventsABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves ZumaEvents contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getZumaEventsByChainId(chainId);
 */
function getZumaEventsByChainId(
  chainId: number | undefined
): ZumaEventsInfoType {
  if (!chainId) {
    return { abi: ZumaEventsABI.abi };
  }

  const entry =
    ZumaEventsAddresses[chainId.toString() as keyof typeof ZumaEventsAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: ZumaEventsABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: ZumaEventsABI.abi,
  };
}

/*
 * Main ZumaEvents React hook with event management functionality:
 *  - createEvent: Create new events with encrypted thresholds
 *  - attendEvent: Attend events with encrypted age and skill
 *  - getAcceptedCount: Get and decrypt accepted count
 *  - closeEvent: Close events
 *  - refreshEvents: Refresh event data
 */
export const useZumaEvents = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [nextEventId, setNextEventId] = useState<bigint | undefined>(undefined);
  const [selectedEventId, setSelectedEventId] = useState<number | undefined>(undefined);
  const [selectedEventData, setSelectedEventData] = useState<EventData | undefined>(undefined);
  const [acceptedCountHandle, setAcceptedCountHandle] = useState<string | undefined>(undefined);
  const [clearAcceptedCount, setClearAcceptedCount] = useState<ClearValueType | undefined>(undefined);
  
  const [isCreatingEvent, setIsCreatingEvent] = useState<boolean>(false);
  const [isAttending, setIsAttending] = useState<boolean>(false);
  const [isGettingCount, setIsGettingCount] = useState<boolean>(false);
  const [isClosingEvent, setIsClosingEvent] = useState<boolean>(false);
  const [isRefreshingEvents, setIsRefreshingEvents] = useState<boolean>(false);
  
  const [message, setMessage] = useState<string>("");

  // Event tracking states
  const [lastCreatedEvent, setLastCreatedEvent] = useState<CreatedEvent | undefined>(undefined);
  const [lastAttendanceResult, setLastAttendanceResult] = useState<AttendanceResult | undefined>(undefined);

  // Form states
  const [eventForm, setEventForm] = useState<EventForm>({
    name: "",
    description: "",
    dateTime: "",
    location: "",
    minAge: "",
    minSkill: "",
  });

  const [attendanceForm, setAttendanceForm] = useState<AttendanceForm>({
    eventId: "",
    age: "",
    skill: "",
  });

  // Refs for stale checks
  const zumaEventsRef = useRef<ZumaEventsInfoType | undefined>(undefined);
  const isCreatingEventRef = useRef<boolean>(isCreatingEvent);
  const isAttendingRef = useRef<boolean>(isAttending);
  const isGettingCountRef = useRef<boolean>(isGettingCount);
  const isClosingEventRef = useRef<boolean>(isClosingEvent);
  const isRefreshingEventsRef = useRef<boolean>(isRefreshingEvents);

  const isCountDecrypted = acceptedCountHandle && acceptedCountHandle === clearAcceptedCount?.handle;

  //////////////////////////////////////////////////////////////////////////////
  // ZumaEvents Contract
  //////////////////////////////////////////////////////////////////////////////

  const zumaEvents = useMemo(() => {
    const c = getZumaEventsByChainId(chainId);
    zumaEventsRef.current = c;

    if (!c.address) {
      setMessage(`ZumaEvents deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Deployment Status
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!zumaEvents) {
      return undefined;
    }
    return Boolean(zumaEvents.address) && zumaEvents.address !== ethers.ZeroAddress;
  }, [zumaEvents]);

  //////////////////////////////////////////////////////////////////////////////
  // Event Creation
  //////////////////////////////////////////////////////////////////////////////

  const canCreateEvent = useMemo(() => {
    return (
      zumaEvents.address &&
      ethersSigner &&
      !isCreatingEvent &&
      eventForm.name &&
      eventForm.description &&
      eventForm.dateTime &&
      eventForm.location &&
      eventForm.minAge &&
      eventForm.minSkill
    );
  }, [
    zumaEvents.address,
    ethersSigner,
    isCreatingEvent,
    eventForm.name,
    eventForm.description,
    eventForm.dateTime,
    eventForm.location,
    eventForm.minAge,
    eventForm.minSkill,
  ]);

  const updateEventForm = useCallback((field: keyof EventForm, value: string) => {
    setEventForm(prev => ({ ...prev, [field]: value }));
  }, []);

  const createEvent = useCallback(() => {
    if (isCreatingEventRef.current) {
      return;
    }

    if (!zumaEvents.address || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisZumaEventsAddress = zumaEvents.address;
    const thisEthersSigner = ethersSigner;
    const thisEventForm = eventForm;

    isCreatingEventRef.current = true;
    setIsCreatingEvent(true);
    setMessage("Creating event...");

    const run = async () => {
      const isStale = () =>
        thisZumaEventsAddress !== zumaEventsRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const contract = new ethers.Contract(
          thisZumaEventsAddress,
          zumaEvents.abi,
          thisEthersSigner
        );

        const tx = await contract.createEvent(
          thisEventForm.name,
          thisEventForm.description,
          thisEventForm.dateTime,
          thisEventForm.location,
          parseInt(thisEventForm.minAge),
          parseInt(thisEventForm.minSkill)
        );

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        if (isStale()) {
          setMessage("Ignore event creation");
          return;
        }

        // Extract event ID from the event log
        const eventCreatedLog = receipt?.logs.find(log => 
          log.topics[0] === contract.interface.getEventTopic('EventCreated')
        );
        
        let eventId = 0;
        if (eventCreatedLog && eventCreatedLog.topics[1]) {
          eventId = parseInt(eventCreatedLog.topics[1], 16);
        } else {
          // Fallback: get the next event ID - 1
          const nextId = await contract.nextEventId();
          eventId = Number(nextId) - 1;
        }

        setMessage(`Event created successfully! Event ID: ${eventId}`);
        
        // Track the created event
        setLastCreatedEvent({
          id: eventId,
          name: thisEventForm.name,
          minAge: parseInt(thisEventForm.minAge),
          minSkill: parseInt(thisEventForm.minSkill)
        });
        
        // Clear confirmation after 10 seconds
        setTimeout(() => setLastCreatedEvent(undefined), 10000);
        
        // Reset form
        setEventForm({
          name: "",
          description: "",
          dateTime: "",
          location: "",
          minAge: "",
          minSkill: "",
        });

        // Refresh events
        refreshEvents();
      } catch (error) {
        setMessage(`Event creation failed: ${error}`);
      } finally {
        isCreatingEventRef.current = false;
        setIsCreatingEvent(false);
      }
    };

    run();
  }, [
    zumaEvents.address,
    zumaEvents.abi,
    ethersSigner,
    chainId,
    eventForm,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Event Attendance
  //////////////////////////////////////////////////////////////////////////////

  const canAttend = useMemo(() => {
    return (
      zumaEvents.address &&
      instance &&
      ethersSigner &&
      !isAttending &&
      attendanceForm.eventId &&
      attendanceForm.age &&
      attendanceForm.skill
    );
  }, [
    zumaEvents.address,
    instance,
    ethersSigner,
    isAttending,
    attendanceForm.eventId,
    attendanceForm.age,
    attendanceForm.skill,
  ]);

  const updateAttendanceForm = useCallback((field: keyof AttendanceForm, value: string) => {
    setAttendanceForm(prev => ({ ...prev, [field]: value }));
  }, []);

  const attendEvent = useCallback(() => {
    if (isAttendingRef.current) {
      return;
    }

    if (!zumaEvents.address || !instance || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisZumaEventsAddress = zumaEvents.address;
    const thisEthersSigner = ethersSigner;
    const thisAttendanceForm = attendanceForm;

    isAttendingRef.current = true;
    setIsAttending(true);
    setMessage("Attending event...");

    const run = async () => {
      const isStale = () =>
        thisZumaEventsAddress !== zumaEventsRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        // Encrypt age
        const encryptedAge = await instance.createEncryptedInput(
          thisZumaEventsAddress,
          thisEthersSigner.address
        );
        encryptedAge.add64(parseInt(thisAttendanceForm.age));
        const encAge = await encryptedAge.encrypt();

        // Encrypt skill
        const encryptedSkill = await instance.createEncryptedInput(
          thisZumaEventsAddress,
          thisEthersSigner.address
        );
        encryptedSkill.add64(parseInt(thisAttendanceForm.skill));
        const encSkill = await encryptedSkill.encrypt();

        if (isStale()) {
          setMessage("Ignore attendance");
          return;
        }

        setMessage("Submitting attendance...");

        const contract = new ethers.Contract(
          thisZumaEventsAddress,
          zumaEvents.abi,
          thisEthersSigner
        );

        const tx = await contract.attend(
          parseInt(thisAttendanceForm.eventId),
          encAge.handles[0],
          encAge.inputProof,
          encSkill.handles[0],
          encSkill.inputProof
        );

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        if (isStale()) {
          setMessage("Ignore attendance");
          return;
        }

        // Check if attendance was accepted by getting the accepted count
        const acceptedCountBefore = await contract.getAcceptedCount(parseInt(thisAttendanceForm.eventId));
        
        // Wait a bit for the transaction to be processed
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        const acceptedCountAfter = await contract.getAcceptedCount(parseInt(thisAttendanceForm.eventId));
        
        // If the count increased, attendance was accepted
        const wasAccepted = acceptedCountAfter !== acceptedCountBefore;
        
        setMessage(wasAccepted ? "Attendance submitted successfully!" : "Attendance submitted but requirements not met.");
        
        // Track attendance result
        setLastAttendanceResult({
          eventId: parseInt(thisAttendanceForm.eventId),
          age: parseInt(thisAttendanceForm.age),
          skill: parseInt(thisAttendanceForm.skill),
          accepted: wasAccepted
        });
        
        // Clear confirmation after 10 seconds
        setTimeout(() => setLastAttendanceResult(undefined), 10000);
        
        // Reset form
        setAttendanceForm({
          eventId: "",
          age: "",
          skill: "",
        });

        // Refresh events
        refreshEvents();
      } catch (error) {
        setMessage(`Attendance failed: ${error}`);
      } finally {
        isAttendingRef.current = false;
        setIsAttending(false);
      }
    };

    run();
  }, [
    zumaEvents.address,
    zumaEvents.abi,
    instance,
    ethersSigner,
    chainId,
    attendanceForm,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Get Accepted Count
  //////////////////////////////////////////////////////////////////////////////

  const canGetCount = useMemo(() => {
    return (
      zumaEvents.address &&
      instance &&
      ethersSigner &&
      !isGettingCount &&
      selectedEventId !== undefined
    );
  }, [
    zumaEvents.address,
    instance,
    ethersSigner,
    isGettingCount,
    selectedEventId,
  ]);

  const getAcceptedCount = useCallback(() => {
    if (isGettingCountRef.current) {
      return;
    }

    if (!zumaEvents.address || !instance || !ethersSigner || selectedEventId === undefined) {
      return;
    }

    const thisChainId = chainId;
    const thisZumaEventsAddress = zumaEvents.address;
    const thisEthersSigner = ethersSigner;
    const thisEventId = selectedEventId;

    isGettingCountRef.current = true;
    setIsGettingCount(true);
    setMessage("Getting accepted count...");

    const run = async () => {
      const isStale = () =>
        thisZumaEventsAddress !== zumaEventsRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const contract = new ethers.Contract(
          thisZumaEventsAddress,
          zumaEvents.abi,
          thisEthersSigner
        );

        const encryptedCount = await contract.getAcceptedCount(thisEventId);

        if (isStale()) {
          setMessage("Ignore getting count");
          return;
        }

        setAcceptedCountHandle(encryptedCount);
        setMessage("Got encrypted count, decrypting...");

        // Decrypt the count
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [zumaEvents.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore decryption");
          return;
        }

        const res = await instance.userDecrypt(
          [{ handle: encryptedCount, contractAddress: thisZumaEventsAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        if (isStale()) {
          setMessage("Ignore decryption result");
          return;
        }

        const clearCount = res[encryptedCount];
        setClearAcceptedCount({ handle: encryptedCount, clear: clearCount });
        setMessage(`Accepted count decrypted: ${clearCount}`);
      } catch (error) {
        setMessage(`Getting count failed: ${error}`);
      } finally {
        isGettingCountRef.current = false;
        setIsGettingCount(false);
      }
    };

    run();
  }, [
    zumaEvents.address,
    zumaEvents.abi,
    instance,
    ethersSigner,
    chainId,
    selectedEventId,
    fhevmDecryptionSignatureStorage,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Close Event
  //////////////////////////////////////////////////////////////////////////////

  const canCloseEvent = useMemo(() => {
    return (
      zumaEvents.address &&
      ethersSigner &&
      !isClosingEvent &&
      selectedEventId !== undefined
    );
  }, [
    zumaEvents.address,
    ethersSigner,
    isClosingEvent,
    selectedEventId,
  ]);

  const closeEvent = useCallback(() => {
    if (isClosingEventRef.current) {
      return;
    }

    if (!zumaEvents.address || !ethersSigner || selectedEventId === undefined) {
      return;
    }

    const thisChainId = chainId;
    const thisZumaEventsAddress = zumaEvents.address;
    const thisEthersSigner = ethersSigner;
    const thisEventId = selectedEventId;

    isClosingEventRef.current = true;
    setIsClosingEvent(true);
    setMessage("Closing event...");

    const run = async () => {
      const isStale = () =>
        thisZumaEventsAddress !== zumaEventsRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const contract = new ethers.Contract(
          thisZumaEventsAddress,
          zumaEvents.abi,
          thisEthersSigner
        );

        const tx = await contract.closeEvent(thisEventId);

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        if (isStale()) {
          setMessage("Ignore event closing");
          return;
        }

        setMessage("Event closed successfully!");
        refreshEvents();
      } catch (error) {
        setMessage(`Event closing failed: ${error}`);
      } finally {
        isClosingEventRef.current = false;
        setIsClosingEvent(false);
      }
    };

    run();
  }, [
    zumaEvents.address,
    zumaEvents.abi,
    ethersSigner,
    chainId,
    selectedEventId,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Refresh Events
  //////////////////////////////////////////////////////////////////////////////

  const canRefreshEvents = useMemo(() => {
    return zumaEvents.address && ethersReadonlyProvider && !isRefreshingEvents;
  }, [zumaEvents.address, ethersReadonlyProvider, isRefreshingEvents]);

  const refreshEvents = useCallback(() => {
    if (isRefreshingEventsRef.current) {
      return;
    }

    if (!zumaEvents.address || !ethersReadonlyProvider) {
      return;
    }

    isRefreshingEventsRef.current = true;
    setIsRefreshingEvents(true);

    const run = async () => {
      try {
        const contract = new ethers.Contract(
          zumaEvents.address,
          zumaEvents.abi,
          ethersReadonlyProvider
        );

        // Get next event ID
        const nextId = await contract.nextEventId();
        setNextEventId(nextId);

        // If we have a selected event, get its data
        if (selectedEventId !== undefined) {
          const eventData = await contract.events(selectedEventId);
          setSelectedEventData(eventData);
        }

        setMessage("Events refreshed successfully!");
      } catch (error) {
        setMessage(`Refreshing events failed: ${error}`);
      } finally {
        isRefreshingEventsRef.current = false;
        setIsRefreshingEvents(false);
      }
    };

    run();
  }, [
    zumaEvents.address,
    zumaEvents.abi,
    ethersReadonlyProvider,
    selectedEventId,
  ]);

  // Auto refresh events
  useEffect(() => {
    refreshEvents();
  }, [refreshEvents]);

  //////////////////////////////////////////////////////////////////////////////
  // Event Selection
  //////////////////////////////////////////////////////////////////////////////

  const selectEvent = useCallback((eventId: number) => {
    setSelectedEventId(eventId);
    setSelectedEventData(undefined);
    setAcceptedCountHandle(undefined);
    setClearAcceptedCount(undefined);
    
    // If we have a valid event ID, fetch its data
    if (eventId !== undefined && zumaEvents.address && ethersReadonlyProvider) {
      const fetchEventData = async () => {
        try {
          const contract = new ethers.Contract(
            zumaEvents.address,
            zumaEvents.abi,
            ethersReadonlyProvider
          );
          const eventData = await contract.events(eventId);
          setSelectedEventData(eventData);
        } catch (error) {
          console.error("Failed to fetch event data:", error);
        }
      };
      fetchEventData();
    }
  }, [zumaEvents.address, zumaEvents.abi, ethersReadonlyProvider]);

  return {
    // Contract info
    contractAddress: zumaEvents.address,
    isDeployed,
    
    // Event data
    nextEventId,
    selectedEventId,
    selectedEventData,
    acceptedCountHandle,
    clearAcceptedCount,
    isCountDecrypted,
    
    // Event tracking
    lastCreatedEvent,
    lastAttendanceResult,
    
    // Form states
    eventForm,
    attendanceForm,
    updateEventForm,
    updateAttendanceForm,
    
    // Status flags
    isCreatingEvent,
    isAttending,
    isGettingCount,
    isClosingEvent,
    isRefreshingEvents,
    
    // Capability flags
    canCreateEvent,
    canAttend,
    canGetCount,
    canCloseEvent,
    canRefreshEvents,
    
    // Actions
    createEvent,
    attendEvent,
    getAcceptedCount,
    closeEvent,
    refreshEvents,
    selectEvent,
    
    // Message
    message,
  };
};
